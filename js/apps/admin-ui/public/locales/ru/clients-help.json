{
	"enableDisable": "비활성화된 클라이언트는 로그인을 시작하거나 액세스 토큰을 얻을 수 없습니다.",
	"clientType": "'OpenID Connect'를 통해 클라이언트는 권한 부여 서버에서 수행한 인증을 기반으로 최종 사용자의 신원을 확인할 수 있습니다. 'SAML은 크로스 도메인 싱글 사인온 (SSO) 을 비롯한 웹 기반 인증 및 권한 부여 시나리오를 지원하며 어설션이 포함된 보안 토큰을 사용하여 정보를 전달합니다.",
	"serviceAccount": "이 클라이언트를 Keycloak에 인증하고 이 클라이언트 전용 액세스 토큰을 검색할 수 있습니다.이를 통해 OAuth2 사양 측면에서 이 클라이언트에 대한 '클라이언트 자격 증명 부여'를 지원할 수 있습니다.",
	"manageServiceAccountUser": "세부 정보 및 그룹 매핑을 관리하려면 사용자 이름 <1>{{link</1>}} 을 클릭합니다.",
	"authentication": "이는 OIDC 클라이언트의 유형을 정의합니다.ON이면 OIDC 유형이 기밀 액세스 유형으로 설정됩니다.OFF일 때는 공개 액세스 유형으로 설정됩니다.",
	"authorization": "클라이언트에 대한 세분화된 권한 부여 지원 활성화/비활성화",
	"authDetails": "이 리소스 서버의 모든 리소스 설정을 내보내고 다운로드합니다.",
	"directAccess": "이를 통해 Direct Access Grants를 지원할 수 있습니다. 즉, 클라이언트가 사용자의 사용자 이름/비밀번호에 액세스하고 이를 Keycloak 서버와 직접 교환하여 액세스 토큰으로 교환할 수 있습니다.OAuth2 사양 측면에서 보면 이 클라이언트에 대한 '리소스 소유자 암호 자격 증명 부여'를 지원할 수 있습니다.",
	"standardFlow": "이렇게 하면 인증 코드를 사용한 표준 OpenID Connect 리디렉션 기반 인증이 가능합니다.OpenID Connect 또는 OAuth2 사양 측면에서 보면 이 클라이언트에 대한 '인증 코드 흐름'을 지원할 수 있습니다.",
	"implicitFlow": "이를 통해 인증 코드 없이 OpenID Connect 리디렉션 기반 인증을 지원할 수 있습니다.OpenID Connect 또는 OAuth2 사양 측면에서 보면 이 클라이언트에 대한 '암시적 흐름'을 지원할 수 있습니다.",
	"oauthDeviceAuthorizationGrant": "이를 통해 OAuth 2.0 기기 인증 부여를 지원할 수 있습니다. 즉, 클라이언트는 입력 기능이 제한적이거나 적합한 브라우저가 없는 기기의 애플리케이션입니다.",
	"oidcCibaGrant": "이를 통해 OIDC CIBA Grant를 지원할 수 있습니다. 즉, 사용자는 사용자의 브라우저 대신 일부 외부 인증 장치를 통해 인증됩니다.",
	"rootURL": "상대 URL에 추가된 루트 URL",
	"validRedirectURIs": "로그인에 성공하면 브라우저가 리디렉션할 수 있는 유효한 URI 패턴입니다.'http://example.com/ *'와 같은 간단한 와일드카드를 사용할 수 있습니다./my/relative/path/ *와 같은 상대 경로도 지정할 수 있습니다.상대 경로는 클라이언트 루트 URL을 기준으로 하며, 지정된 경로가 없는 경우 인증 서버 루트 URL이 사용됩니다.SAML의 경우 로그인 요청에 포함된 소비자 서비스 URL을 사용하는 경우 유효한 URI 패턴을 설정해야 합니다.",
	"validPostLogoutRedirectURIs": "로그아웃 성공 후 브라우저가 리디렉션할 수 있는 유효한 URI 패턴입니다.값이 '+'이거나 빈 필드는 유효한 리디렉션 URI 목록을 사용합니다.값이 '-'이면 로그아웃 후 리디렉션 URI를 허용하지 않습니다.'http://example.com/ *'와 같은 간단한 와일드카드를 사용할 수 있습니다./my/relative/path/ *와 같은 상대 경로도 지정할 수 있습니다.상대 경로는 클라이언트 루트 URL을 기준으로 하며, 지정된 경로가 없는 경우 인증 서버 루트 URL이 사용됩니다.",
	"nameIdFormat": "제목에 사용할 이름 ID 형식입니다.",
	"alwaysDisplayInUI": "사용자에게 활성 세션이 없더라도 항상 계정 UI에 이 클라이언트를 나열하십시오.",
	"forceNameIdFormat": "요청된 NameID 제목 형식을 무시하고 관리자 UI로 구성된 형식을 사용하십시오.",
	"forcePostBinding": "응답에는 항상 POST 바인딩을 사용하십시오.",
	"forceArtifactBinding": "SAML ARTIFACT 바인딩 시스템을 통해 응답 메시지를 클라이언트에 반환해야 합니까?",
	"includeAuthnStatement": "메서드와 타임스탬프를 지정하는 명령문을 로그인 응답에 포함해야 하나요?",
	"includeOneTimeUseCondition": "로그인 응답에 일회성 사용 조건을 포함해야 하나요?",
	"optimizeLookup": "<Extensions>Keycloak 어댑터로 보호되는 SP용 REDIRECT 바인딩에서 SAML 문서에 서명할 때 서명 키의 ID를 요소의 SAML 프로토콜 메시지에 포함해야 합니까?이렇게 하면 검증 당사자가 알려진 모든 키를 검증하는 대신 단일 키를 사용하므로 서명 검증이 최적화됩니다.",
	"signDocuments": "영역에서 SAML 문서에 서명해야 하나요?",
	"signAssertions": "SAML 문서 내의 어설션에 서명해야 할까요?문서가 이미 서명된 경우에는 이 설정이 필요하지 않습니다.",
	"signatureAlgorithm": "문서에 서명할 때 사용하는 서명 알고리즘입니다.참고로 'SHA1' 기반 알고리즘은 지원 중단되었으며 향후 제거될 수 있습니다.'*_SHA1' 대신 좀 더 안전한 알고리즘을 사용하는 것이 좋습니다.",
	"signatureKeyName": "서명된 SAML 문서에는 KeyName 요소의 서명 키 ID가 포함되어 있습니다.키클로크/RH-SSO 상대방의 경우 KEY_ID를 사용하고, MS ADFS의 경우 CERT_SUBJECT를 사용하고, 다른 옵션이 작동하지 않으면 NONE을 사용하십시오.",
	"canonicalization": "XML 서명의 표준화 방법.",
	"webOrigins": "CORS 출처를 허용했습니다.유효한 리디렉션 URI의 모든 출처를 허용하려면 '+'를 추가하십시오.하지만 여기에는 '*' 와일드카드가 포함되지 않습니다.모든 오리진을 허용하려면 명시적으로 '*'를 추가하세요.",
	"homeURL": "인증 서버가 클라이언트로 리디렉션하거나 다시 연결해야 할 때 사용할 기본 URL입니다.",
	"adminURL": "클라이언트의 관리 인터페이스 URL입니다.클라이언트가 어댑터 REST API를 지원하는 경우 이를 설정하십시오.이 REST API를 사용하면 인증 서버가 해지 정책 및 기타 관리 작업을 푸시할 수 있습니다.일반적으로 이 URL은 클라이언트의 기본 URL로 설정됩니다.",
	"client": "이 권한 부여 요청을 하는 클라이언트를 선택합니다.제공되지 않은 경우, 사용 중인 클라이언트에 따라 승인 요청이 이루어집니다.",
	"clientId": "URI 및 토큰에서 참조되는 ID를 지정합니다.예: '내 클라이언트'SAML의 경우 이는 인증 요청에서 예상되는 발급자 값이기도 합니다.",
	"selectUser": "서버에서 권한을 쿼리하는 데 사용할 ID를 가진 사용자를 선택합니다.",
	"roles": "선택한 사용자와 연결할 역할을 선택합니다.",
	"contextualAttributes": "실행 환경 또는 실행 컨텍스트에서 제공하는 모든 속성",
	"resourceType": "이 권한이 지정된 유형의 모든 리소스 인스턴스에 적용되어야 함을 지정합니다.",
	"applyToResourceType": "이 권한을 지정된 유형의 모든 리소스에 적용할지 여부를 지정합니다.이 경우 해당 권한은 지정된 리소스 유형의 모든 인스턴스에 대해 평가됩니다.",
	"resources": "이 권한을 특정 리소스 인스턴스에 적용해야 하도록 지정합니다.",
	"scopesSelect": "이 권한을 하나 이상의 범위에 적용해야 하도록 지정합니다.",
	"clientName": "클라이언트의 표시 이름을 지정합니다.예: '내 클라이언트'.현지화된 값에 대한 키도 지원합니다.예: $ {my_client}",
	"description": "클라이언트에 대한 설명을 지정합니다.예: '작업표용 내 클라이언트'.현지화된 값에 대한 키도 지원합니다.예: $ {my_클라이언트_설명}",
	"loginTheme": "로그인, OTP, 권한 부여, 등록, 비밀번호 찾기 페이지의 테마를 선택하세요.",
	"encryptAssertions": "AES를 사용하여 SAML 어설션을 클라이언트의 공개 키로 암호화해야 합니까?",
	"clientSignature": "클라이언트가 saml 요청과 응답에 서명할까요?그리고 검증을 받아야 할까요?",
	"downloadType": "다운로드 유형에 대한 정보입니다.",
	"details": "이것은 세부 사항에 대한 정보입니다",
	"clientPolicyName": "정책의 디스플레이 이름",
	"createToken": "초기 액세스 토큰은 클라이언트를 만드는 데만 사용할 수 있습니다.",
	"expiration": "토큰의 유효 기간을 지정합니다.",
	"count": "토큰을 사용하여 생성할 수 있는 클라이언트 수를 지정합니다.",
	"client-authenticator-type": "Keycloak 서버에 대한 이 클라이언트의 인증에 사용되는 클라이언트 인증자",
	"registration-access-token": "등록 액세스 토큰은 클라이언트가 클라이언트 등록 서비스에 액세스할 수 있도록 합니다.",
	"signature-algorithm": "JWA 알고리즘은 클라이언트가 인증을 위해 JWT에 서명할 때 사용해야 하는 알고리즘입니다.공란으로 남겨 두면 클라이언트는 모든 알고리즘을 사용할 수 있습니다.",
	"anonymousAccessPolicies": "이러한 정책은 인증되지 않은 요청에 의해 클라이언트 등록 서비스가 호출될 때 사용됩니다.즉, 요청에는 초기 액세스 토큰이나 베어러 토큰이 포함되지 않습니다.",
	"authenticatedAccessPolicies": "이러한 정책은 인증된 요청에 의해 클라이언트 등록 서비스가 호출될 때 사용됩니다.즉, 요청에 초기 액세스 토큰 또는 베어러 토큰이 포함됩니다.",
	"allowRegexComparison": "OFF인 경우 지정된 클라이언트 인증서의 주체 DN이 RFC8705 사양에 설명된 대로 '주체 DN' 속성의 지정된 DN과 정확히 일치해야 합니다.주제 DN은 RFC2553 또는 RFC1779 형식일 수 있습니다.ON인 경우 지정된 클라이언트 인증서의 주체 DN이 'Subject DN' 속성에 지정된 정규식과 일치해야 합니다.",
	"subject": "클라이언트 인증서의 주체 DN을 검증하기 위한 정규 표현식입니다.“(.*?) 사용(?:$)” 를 입력하면 모든 종류의 표현식과 일치합니다.",
	"evaluateExplain": "이 페이지에서는 모든 프로토콜 매퍼와 역할 범위 매핑을 볼 수 있습니다.",
	"effectiveProtocolMappers": "모든 기본 클라이언트 범위와 선택한 선택적 범위를 포함합니다.클라이언트에 발급된 액세스 토큰을 생성할 때 모든 클라이언트 범위의 모든 프로토콜 매퍼와 역할 범위 매핑이 사용됩니다.",
	"effectiveRoleScopeMappings": "이 클라이언트에 대한 액세스 토큰을 발급할 때 사용할 선택적 클라이언트 범위를 선택했습니다.클라이언트 어댑터에서 초기 OpenID Connect 인증 요청을 보낼 때 이러한 선택적 클라이언트 범위를 적용하려는 경우 사용해야 하는 OAuth Scope 매개 변수의 값을 위에서 확인할 수 있습니다.",
	"generatedAccessToken": "선택한 사용자가 인증되면 생성된 액세스 토큰이 클라이언트로 전송되는 예제 액세스 토큰을 참조하십시오.효과적인 프로토콜 매퍼 및 역할 범위 매핑과 사용자 자신에게 할당된 클레임/역할을 기반으로 토큰에 포함될 클레임과 역할을 확인할 수 있습니다.",
	"generatedIdToken": "선택한 사용자가 인증되면 생성되어 클라이언트에 전송되는 예제 ID 토큰을 참조하십시오.효과적인 프로토콜 매퍼 및 역할 범위 매핑과 사용자 자신에게 할당된 클레임/역할을 기반으로 토큰에 포함될 클레임과 역할을 확인할 수 있습니다.",
	"generatedUserInfo": "사용자 정보 엔드포인트에서 제공하는 예제 사용자 정보를 참조하십시오.",
	"scopeParameter": "범위 매개 변수의 이 값을 복사/붙여넣고 이 클라이언트 어댑터에서 보낸 초기 OpenID Connect 인증 요청에 사용할 수 있습니다.이 클라이언트에 발급된 토큰을 생성할 때 기본 클라이언트 범위와 선택된 선택적 클라이언트 범위가 사용됩니다.",
	"user": "필요에 따라 예제 액세스 토큰을 생성할 사용자를 선택합니다.사용자를 선택하지 않으면 평가 중에 예제 액세스 토큰이 생성되지 않습니다.",
	"notBefore": "이 시간 이전에 발행된 모든 토큰을 이 클라이언트에 대해 취소하십시오.정책을 푸시하려면 먼저 설정 탭에서 유효한 관리자 URL을 설정해야 합니다.",
	"notBeforeIntro": "해지 정책을 클라이언트에 성공적으로 푸시하려면 먼저 이 클라이언트의 <1>설정</1> 탭에서 관리자 URL을 설정해야 합니다.",
	"notBeforeTooltip": "관리자 URL은 먼저 설정 탭에서 설정해야 합니다.",
	"nodeReRegistrationTimeout": "등록된 클라이언트 클러스터 노드를 재등록할 최대 시간을 지정하는 간격입니다.이 시간 내에 클러스터 노드가 Keycloak에 재등록 요청을 보내지 않으면 Keycloak에서 등록이 취소됩니다.",
	"fineGrainOpenIdConnectConfiguration": "이 섹션은 OpenID Connect 프로토콜과 관련된 이 클라이언트의 고급 설정을 구성하는 데 사용됩니다.",
	"fineGrainSamlEndpointConfig": "이 섹션에서는 어설션 소비자 및 단일 로그아웃 서비스에 대한 정확한 URL을 구성합니다.",
	"logoUrl": "클라이언트 애플리케이션의 로고를 참조하는 URL",
	"policyUrl": "신뢰할 수 있는 당사자 클라이언트가 프로필 데이터가 사용되는 방식을 읽을 수 있도록 최종 사용자에게 제공하는 URL",
	"policyUsers": "이 정책에서 허용되는 사용자를 지정합니다.",
	"termsOfServiceUrl": "신뢰 당사자 클라이언트가 신뢰 당사자의 서비스 약관을 읽을 수 있도록 최종 사용자에게 제공하는 URL",
	"accessTokenSignatureAlgorithm": "액세스 토큰 서명에 사용되는 JWA 알고리즘.",
	"idTokenSignatureAlgorithm": "ID 토큰 서명에 사용되는 JWA 알고리즘.",
	"idTokenEncryptionKeyManagementAlgorithm": "JWA 알고리즘은 ID 토큰을 암호화할 때 키 관리에 사용됩니다.암호화된 ID 토큰을 원할 경우 이 옵션이 필요합니다.비어 있는 경우 ID 토큰은 서명만 되지만 암호화되지는 않습니다.",
	"idTokenEncryptionContentEncryptionAlgorithm": "ID 토큰을 암호화할 때 콘텐츠 암호화에 사용되는 JWA 알고리즘.이 옵션은 암호화된 ID 토큰을 원하는 경우에만 필요합니다.비어 있는 경우 ID 토큰은 서명만 되지만 암호화되지는 않습니다.",
	"userInfoSignedResponseAlgorithm": "서명된 사용자 정보 엔드포인트 응답에 사용되는 JWA 알고리즘입니다.'unsigned (unsigned) '로 설정하면 사용자 정보 응답이 서명되지 않고 애플리케이션/json 형식으로 반환됩니다.",
	"userInfoResponseEncryptionKeyManagementAlgorithm": "JWA 알고리즘은 사용자 정보 엔드포인트 응답을 암호화할 때 키 관리에 사용됩니다.암호화된 사용자 정보 엔드포인트 응답을 원하는 경우 이 옵션이 필요합니다.비워 두면 사용자 정보 엔드포인트 응답이 암호화되지 않습니다.",
	"userInfoResponseEncryptionContentEncryptionAlgorithm": "사용자 정보 엔드포인트 응답을 암호화할 때 콘텐츠 암호화에 사용되는 JWA 알고리즘.사용자 정보 응답 암호화 키 관리 알고리즘이 지정된 경우 이 값의 기본값은 A128CBC-HS256 입니다.",
	"requestObjectSignatureAlgorithm": "JWA 알고리즘은 클라이언트가 '요청' 또는 'request_uri' 매개변수로 지정된 OIDC 요청 객체를 전송할 때 사용해야 하는 알고리즘입니다.'any'로 설정하면 모든 알고리즘 ('none' 포함) 으로 요청 객체에 서명할 수 있습니다.",
	"requestObjectRequired": "클라이언트가 권한 부여 요청과 함께 요청 객체를 제공해야 하는지 여부와 이에 사용할 수 있는 방법을 지정합니다.“필수 아님”으로 설정된 경우 요청 객체 제공은 선택 사항입니다.다른 모든 경우에는 요청 객체 제공이 필수입니다.“request”로 설정하면 요청 객체를 값으로 제공해야 합니다.“request_uri”로 설정하면 요청 객체를 참조로 제공해야 합니다.“요청 또는 request_uri”로 설정하면 두 방법 중 하나를 사용할 수 있습니다.",
	"requestObjectEncryption": "JWE 알고리즘은 클라이언트가 '요청' 또는 'request_uri' 매개변수로 지정된 OIDC 요청 객체를 전송할 때 사용해야 하는 알고리즘입니다.'any'로 설정하면 암호화는 선택 사항이며 모든 알고리즘이 허용됩니다.",
	"requestObjectEncoding": "JWE 알고리즘. 클라이언트가 'request' 또는 'request_uri' 매개 변수로 지정된 OIDC 요청 객체의 내용을 암호화할 때 사용해야 하는 알고리즘입니다.'any'로 설정하면 모든 알고리즘이 허용됩니다.",
	"validRequestURIs": "OpenID 연결 인증 요청 중에 'request_uri' 매개 변수의 값으로 사용할 수 있는 유효한 URI 목록입니다.유효한 리디렉션 URI와 같은 기능이 지원됩니다.와일드카드 또는 상대 경로를 예로 들 수 있습니다.",
	"idpInitiatedSsoUrlName": "IDP 개시 SSO를 수행하려는 경우 클라이언트를 참조할 URL 프래그먼트 이름입니다.이 필드를 비워 두면 IDP 개시 SSO가 비활성화됩니다.브라우저에서 참조할 URL은 다음과 같습니다. {서버-루트} /realms/ {realm} /프로토콜/saml/clients/ {클라이언트-URL-이름}",
	"idpInitiatedSsoRelayState": "IDP 개시 SSO를 수행하려는 경우 SAML 요청과 함께 전송하려는 릴레이 상태입니다.",
	"masterSamlProcessingUrl": "구성된 경우 이 URL은 SP의 어설션 소비자 및 단일 로그아웃 서비스에 대한 모든 바인딩에 사용됩니다.Fine Grain SAML 엔드포인트 구성의 각 바인딩 및 서비스에 대해 이를 개별적으로 재정의할 수 있습니다.",
	"authorizationSignedResponseAlg": "응답 모드가 jwt일 때 권한 부여 응답 토큰에 서명하는 데 사용되는 JWA 알고리즘입니다.",
	"authorizationEncryptedResponseAlg": "JWA 알고리즘은 응답 모드가 jwt일 때 권한 부여 응답을 암호화할 때 키 관리에 사용됩니다.암호화된 인증 응답을 원할 경우 이 옵션이 필요합니다.비워 두면 권한 부여 응답이 서명되지만 암호화되지는 않습니다.",
	"authorizationEncryptedResponseEnc": "JWA 알고리즘은 응답 모드가 jwt일 때 권한 부여 응답을 암호화할 때 콘텐츠 암호화에 사용됩니다.암호화된 인증 응답을 원할 경우 이 옵션이 필요합니다.비워 두면 권한 부여 응답이 서명되지만 암호화되지는 않습니다.",
	"openIdConnectCompatibilityModes": "이 섹션은 이전 OpenID Connect/OAuth 2 어댑터와의 이전 버전과의 호환성을 위한 설정을 구성하는 데 사용됩니다.클라이언트가 이전 버전의 Keycloak/RH-SSO 어댑터를 사용하는 경우 특히 유용합니다.",
	"excludeSessionStateFromAuthenticationResponse": "이 기능이 켜져 있는 경우 'session_state' 매개 변수는 OpenID 연결 인증 응답에 포함되지 않습니다.클라이언트가 'session_state' 매개변수를 지원하지 않는 이전 OIDC/OAuth2 어댑터를 사용하는 경우 유용합니다.",
	"useRefreshTokens": "이 기능이 켜져 있으면 refresh_token이 생성되어 토큰 응답에 추가됩니다.이 기능이 꺼져 있으면 refresh 토큰이 생성되지 않습니다.",
	"useRefreshTokenForClientCredentialsGrant": "이 기능이 켜져 있는 경우 client_credentials 부여가 사용되는 경우 refresh 토큰이 생성되고 토큰 응답에 추가됩니다.OAuth 2.0 RFC6749 섹션 4.4.3에는 클라이언트_자격 증명 부여를 사용할 때 새로 고침_토큰을 생성해서는 안 된다고 명시되어 있습니다.이 기능이 꺼져 있으면 refresh_token이 생성되지 않고 연결된 사용자 세션이 제거됩니다.",
	"useLowerCaseBearerType": "이 기능이 켜져 있으면 토큰 응답이 소문자 “베어러” 유형으로 설정됩니다.기본적으로 서버는 RFC6750 정의에 따라 유형을 “베어러”로 설정합니다.",
	"advancedSettingsOpenid-connect": "이 섹션은 OpenID Connect 프로토콜과 관련된 이 클라이언트의 고급 설정을 구성하는 데 사용됩니다.",
	"advancedSettingsSaml": "이 섹션은 이 클라이언트의 고급 설정을 구성하는 데 사용됩니다.",
	"assertionLifespan": "수명은 SAML 어설션 조건에서 설정됩니다.그 시간이 지나면 해당 주장은 무효가 됩니다.“SessionNotOnOrAfter” 속성은 수정되지 않으며 영역 수준에서 정의된 “SSO 세션 최대” 시간을 계속 사용하십시오.",
	"accessTokenLifespan": "액세스 토큰이 만료되기까지의 최대 시간입니다.이 값은 SSO 타임아웃에 비해 짧게 설정하는 것이 좋습니다.",
	"clientSessionIdle": "토큰 새로 고침이 무효화되기 전까지 클라이언트가 유휴 상태로 있을 수 있는 시간입니다.이 옵션은 토큰 시간에만 영향을 주고 글로벌 SSO 세션에는 영향을 주지 않습니다.설정하지 않으면 표준 SSO 세션 유휴 값이 사용됩니다.",
	"clientSessionMax": "클라이언트에 대한 토큰이 무효화되기까지의 최대 시간입니다.이 옵션은 토큰 시간에만 영향을 주고 글로벌 SSO 세션에는 영향을 주지 않습니다.설정하지 않은 경우 표준 SSO 세션 최대값을 사용합니다.",
	"clientOfflineSessionIdle": "오프라인 토큰 새로 고침이 무효화되기 전에 클라이언트가 유휴 상태로 있을 수 있는 시간입니다.이 옵션은 토큰 시간에만 영향을 주고 글로벌 SSO 세션에는 영향을 주지 않습니다.설정하지 않으면 표준 SSO 세션 유휴 값이 사용됩니다.",
	"clientOfflineSessionMax": "클라이언트의 오프라인 토큰이 무효화되기까지의 최대 시간입니다.이 옵션은 토큰 시간에만 영향을 주고 글로벌 SSO 세션에는 영향을 주지 않습니다.설정하지 않은 경우 표준 SSO 세션 최대값을 사용합니다.",
	"oAuthMutual": "이를 통해 OAuth 2.0 상호 TLS 인증서 바인딩 액세스 토큰을 지원할 수 있습니다. 즉, 키클로크는 액세스 토큰과 새로 고침 토큰을 keycloak의 토큰 엔드포인트와 이 클라이언트 간에 상호 TLS로 교환되는 토큰 요청 클라이언트의 X.509 인증서와 바인딩합니다.이러한 토큰은 베어러 토큰이 아닌 홀더 오브 키 토큰으로 취급될 수 있습니다.",
	"keyForCodeExchange": "PKCE에 사용할 코드 챌린지 방법을 선택합니다.지정하지 않으면 keycloak은 클라이언트가 적절한 코드 챌린지 및 코드 교환 방법이 포함된 권한 부여 요청을 보내지 않는 한 클라이언트에 PKCE를 적용하지 않습니다.",
	"pushedAuthorizationRequestRequired": "권한 부여 서버가 푸시된 권한 부여 요청 메서드를 통해서만 권한 부여 요청 데이터를 수락하는지 여부를 나타내는 부울 파라미터입니다.",
	"acrToLoAMapping": "어떤 ACR (인증 컨텍스트 클래스 참조) 값이 어떤 LoA (인증 수준) 에 매핑되는지 정의합니다.ACR은 임의의 값일 수 있지만 LoA는 숫자여야 합니다.",
	"defaultACRValues": "OIDC 요청에 '클레임' 또는 'acr_values' 매개변수에서 요청한 명시적 ACR이 없는 경우 자발적 ACR로 사용할 기본값입니다.",
	"assertionConsumerServicePostBindingURL": "클라이언트의 어설션 소비자 서비스에 대한 SAML POST 바인딩 URL (로그인 응답).이 바인딩에 대한 URL이 없는 경우 비워 둘 수 있습니다.",
	"assertionConsumerServiceRedirectBindingURL": "클라이언트의 어설션 소비자 서비스에 대한 SAML 리디렉션 바인딩 URL (로그인 응답).이 바인딩에 대한 URL이 없는 경우 비워 둘 수 있습니다.",
	"logoutServicePostBindingURL": "클라이언트의 단일 로그아웃 서비스를 위한 SAML POST 바인딩 URL입니다.다른 바인딩을 사용하는 경우 이 필드를 비워 둘 수 있습니다.",
	"logoutServiceRedirectBindingURL": "클라이언트의 단일 로그아웃 서비스를 위한 SAML 리디렉션 바인딩 URL다른 바인딩을 사용하는 경우 이 필드를 비워 둘 수 있습니다.",
	"logoutServiceSoapBindingUrl": "클라이언트의 단일 로그아웃 서비스를 위한 SAML SOAP 바인딩 URL입니다.다른 바인딩을 사용하는 경우 이 필드를 비워 둘 수 있습니다.",
	"logoutServiceArtifactBindingUrl": "클라이언트의 단일 로그아웃 서비스를 위한 SAML 아티팩트 바인딩 URL입니다.다른 바인딩을 사용하는 경우 이 필드를 비워 둘 수 있습니다.",
	"artifactBindingUrl": "HTTP 아티팩트 메시지를 전송할 URL입니다.다른 바인딩을 사용하는 경우 이 필드를 비워 둘 수 있습니다.이 값은 IdP 개시 로그인과 함께 ARTIFACT 바인딩을 강제 실행할 때 설정해야 합니다.",
	"frontchannelLogout": "true인 경우 로그아웃하려면 브라우저를 클라이언트로 리디렉션해야 합니다.false인 경우 서버는 로그아웃을 위한 백그라운드 호출을 수행합니다.",
	"frontchannelLogoutUrl": "이 영역으로 로그아웃 요청이 전송될 때 (end_session_endpoint를 통해) 클라이언트가 스스로 로그아웃하도록 하는 URL입니다.제공되지 않은 경우 기본 URL이 기본값입니다.",
	"backchannelLogoutUrl": "이 영역으로 로그아웃 요청이 전송될 때 (end_session_endpoint를 통해) 클라이언트가 스스로 로그아웃하도록 하는 URL입니다.이 경우 생략하면 클라이언트에게 로그아웃 요청이 전송되지 않습니다.",
	"backchannelLogoutSessionRequired": "백채널 로그아웃 URL을 사용할 때 로그아웃 토큰에 sid (세션 ID) 클레임을 포함할지 여부를 지정합니다.",
	"backchannelLogoutRevokeOfflineSessions": "백채널 로그아웃 URL을 사용할 때 로그아웃 토큰에 “revoke_offline_access” 이벤트를 포함할지 여부를 지정합니다.Keycloak은 이 이벤트로 로그아웃 토큰을 받으면 오프라인 세션을 취소합니다.",
	"artifactResolutionService": "클라이언트를 위한 SAML 아티팩트 확인 서비스.이 엔드포인트는 키클로크가 SOAP 아티팩트 리졸브 메시지를 보내는 엔드포인트입니다.이 바인딩에 대한 URL이 없는 경우 비워 둘 수 있습니다.",
	"authenticationOverrides": "영역 인증 흐름 바인딩을 재정의합니다.",
	"browserFlow": "브라우저 인증에 사용할 흐름을 선택합니다.",
	"directGrant": "직접 부여 인증에 사용할 흐름을 선택합니다.",
	"useJwksUrl": "스위치가 켜져 있는 경우 지정된 JWKS URL에서 클라이언트 공개 키가 다운로드됩니다.이렇게 하면 클라이언트가 새 키 쌍을 생성할 때 항상 새 키가 다시 다운로드되므로 유연성이 뛰어납니다.스위치가 꺼져 있으면 Keycloak DB의 공개 키 (또는 인증서) 가 사용되므로 클라이언트 키 쌍이 변경될 때 항상 새 키 (또는 인증서) 도 Keycloak DB로 가져와야 합니다.",
	"certificate": "클라이언트가 발급하고 키스토어의 클라이언트 개인 키로 서명한 JWT를 검증하기 위한 클라이언트 인증서.",
	"jwksUrl": "JWK 형식의 클라이언트 키가 저장되는 URL입니다.자세한 내용은 JWK 사양을 참조하십시오.“jwt” 자격 증명이 있는 Keycloak 클라이언트 어댑터를 사용하는 경우 접미사가 '/k_jwks'인 앱의 URL을 사용할 수 있습니다.예를 들어 'http://www.myhost.com/myapp/k_jwks'.",
	"generateKeysDescription": "새 키를 생성하면 프라이빗 키가 포함된 키스토어를 자동으로 다운로드하여 클라이언트 측에 저장할 수 있습니다.Keycloak 서버는 인증서와 공개 키만 저장하고 개인 키는 저장하지 않습니다.",
	"archiveFormat": "자바 키스토어 또는 PKCS12 아카이브 형식",
	"keyAlias": "프라이빗 키 및 인증서의 별칭을 보관하세요.",
	"keyPassword": "아카이브의 개인 키에 액세스하기 위한 암호",
	"realmCertificateAlias": "Realm 인증서는 아카이브에도 저장됩니다.이것이 별칭입니다.",
	"storePassword": "아카이브 자체에 액세스하기 위한 암호",
	"consentRequired": "활성화된 경우 사용자는 클라이언트 액세스에 동의해야 합니다.",
	"displayOnClient": "이 클라이언트에 대해 '동의 필요'가 설정된 경우에만 적용됩니다.이 스위치가 꺼져 있으면 동의 화면에는 구성된 클라이언트 범위에 해당하는 동의만 포함됩니다.켜져 있는 경우 동의 화면에도 이 클라이언트 자체에 대한 항목이 하나 표시됩니다.",
	"consentScreenText": "이 클라이언트에 대해 '동의 화면에 클라이언트 표시'가 켜져 있는 경우에만 적용됩니다.이 클라이언트에만 적용되는 권한에 대한 동의 화면에 표시될 텍스트가 들어 있습니다.",
	"import": "이 리소스 서버에 대한 권한 부여 설정이 포함된 JSON 파일을 가져옵니다.",
	"policyEnforcementMode": "정책 적용 모드는 권한 부여 요청을 평가할 때 정책을 적용하는 방법을 결정합니다.'적용'은 지정된 리소스와 관련된 정책이 없는 경우에도 기본적으로 요청이 거부됨을 의미합니다.'허용'은 지정된 리소스와 관련된 정책이 없는 경우에도 요청이 허용됨을 의미합니다.'Disabled'는 정책 평가를 완전히 비활성화하고 모든 리소스에 대한 액세스를 허용합니다.",
	"decisionStrategy": "의사 결정 전략은 권한을 평가하는 방법과 최종 결정을 내리는 방법을 결정합니다.'긍정적'이란 리소스와 해당 범위에 대한 액세스 권한을 부여하기 위해 적어도 하나의 권한이 긍정적인 결정으로 평가되어야 함을 의미합니다.'만장일치'란 최종 결정도 긍정적으로 나오려면 모든 권한이 긍정적인 결정으로 평가되어야 함을 의미합니다.",
	"allowRemoteResourceManagement": "리소스 서버에서 리소스를 원격으로 관리해야 합니까?false인 경우 이 관리 UI에서만 리소스를 관리할 수 있습니다.",
	"resourceName": "이 리소스의 고유한 이름입니다.이름을 사용하여 리소스를 고유하게 식별할 수 있으며, 특정 리소스를 쿼리할 때 유용합니다.",
	"displayName": "사용자에게 친숙한 리소스 이름으로, 주로 사용자 대면 양식을 렌더링할 때 사용됩니다.메시지 번들에서 값을 로드할 수 있도록 국제화를 지원합니다.",
	"type": "이 리소스의 유형.동일한 유형의 여러 리소스 인스턴스를 그룹화하는 데 사용할 수 있습니다.",
	"uris": "리소스로 보호되는 URI 세트입니다.",
	"scopes": "이 리소스와 관련된 범위입니다.",
	"dedicatedScopeExplain": "전용 매퍼와 스코프를 포함하는 클라이언트 스코프입니다.",
	"fullScopeAllowed": "모든 제한을 해제할 수 있습니다.",
	"iconUri": "아이콘을 가리키는 URI입니다.",
	"ownerManagedAccess": "활성화된 경우 리소스 소유자가 이 리소스에 대한 액세스를 관리할 수 있습니다.",
	"resourceAttribute": "리소스와 연관된 속성.",
	"resetActions": "사용자에게 작업 재설정 이메일을 보낼 때 실행할 작업 세트입니다.'이메일 확인'은 사용자에게 이메일 주소를 확인하는 이메일을 보냅니다.'프로필 업데이트'를 위해서는 사용자가 새 개인 정보를 입력해야 합니다.'암호 업데이트'를 수행하려면 사용자가 새 암호를 입력해야 합니다.'OTP 구성'을 수행하려면 모바일 암호 생성기를 설정해야 합니다.",
	"lifespan": "작업 허가가 만료되기 전의 최대 시간.",
	"scopeName": "이 범위의 고유한 이름입니다.이름을 사용하여 범위를 고유하게 식별할 수 있으며 특정 범위를 쿼리할 때 유용합니다.",
	"scopeDisplayName": "이 범위의 고유한 이름입니다.이름을 사용하여 범위를 고유하게 식별할 수 있으며 특정 범위를 쿼리할 때 유용합니다.",
	"policy-name": "이 정책의 이름.",
	"policy-description": "이 정책에 대한 설명입니다.",
	"policyDecisionStagey": "의사 결정 전략은 주어진 권한과 관련된 정책을 평가하는 방법과 최종 결정을 내리는 방법을 결정합니다.'긍정적'이란 최종 결정도 긍정적으로 나오려면 적어도 하나의 정책이 긍정적인 결정으로 평가되어야 함을 의미합니다.'만장일치'란 최종 결정도 긍정적으로 나오려면 모든 정책이 긍정적인 결정으로 평가되어야 함을 의미합니다.'합의'란 긍정적인 결정의 수가 부정적인 결정의 수보다 많아야 한다는 것을 의미합니다.양수와 음수의 수가 같으면 최종 결정은 음수입니다.",
	"applyPolicy": "이 정책 또는 권한으로 정의된 범위에 적용해야 하는 모든 정책을 지정합니다.",
	"policyClient": "이 정책에서 허용되는 클라이언트를 지정합니다.",
	"groupsClaim": "정책을 정의하면 정책은 권한을 요청하는 ID를 나타내는 액세스 토큰 또는 ID 토큰 내에서 지정된 클레임으로부터 사용자 그룹을 가져옵니다.정의되지 않은 경우 영역 구성에서 사용자 그룹을 가져옵니다.",
	"policyGroups": "이 정책에서 허용되는 사용자를 지정합니다.",
	"targetClaim": "정책에서 가져올 대상 클레임을 지정합니다.",
	"regexPattern": "정규식 패턴을 지정합니다.",
	"policyRoles": "이 정책에서 허용하는 클라이언트 역할을 지정합니다.",
	"startTime": "정책이 부여되지 않아야 하는 시간을 정의합니다.현재 날짜/시간이 이 값과 같거나 이후인 경우에만 부여됩니다.",
	"expireTime": "정책이 부여되지 않아야 하는 시간을 정의합니다.현재 날짜/시간이 이 값보다 이전이거나 같은 경우에만 부여됩니다.",
	"month": "정책을 부여해야 하는 달을 정의합니다.두 번째 필드를 채워 범위를 지정할 수도 있습니다.이 경우 이번 달이 입력한 두 값 사이이거나 같은 경우에만 권한이 부여됩니다.",
	"dayMonth": "정책을 부여해야 하는 날짜를 정의합니다.두 번째 필드를 채워 범위를 지정할 수도 있습니다.이 경우 현재 날짜가 입력한 두 값 사이이거나 같은 경우에만 권한이 부여됩니다.",
	"hour": "정책을 반드시 부여해야 하는 시간을 정의합니다.두 번째 필드를 채워 범위를 지정할 수도 있습니다.이 경우 현재 시간이 입력한 두 값 사이이거나 같은 경우에만 권한이 부여됩니다.",
	"minute": "정책을 반드시 부여해야 하는 시간을 정의합니다.두 번째 필드를 채워 범위를 지정할 수도 있습니다.이 경우 현재 분이 입력한 두 값 사이이거나 같은 경우에만 권한이 부여됩니다.",
	"policyCode": "이 정책의 조건을 제공하는 자바스크립트 코드입니다.",
	"logic": "논리는 정책 결정을 내리는 방법을 결정합니다.'긍정적'인 경우 본 정책을 평가하는 동안 얻은 결과 효과 (허용 또는 거부) 를 사용하여 결정을 내립니다.'부정적'인 경우 결과는 무효화됩니다. 즉, 허가는 거부되고 그 반대의 경우도 마찬가지입니다.",
	"permissionName": "이 권한의 이름.",
	"permissionDescription": "이 권한에 대한 설명입니다.",
	"applyToResourceTypeFlag": "이 권한을 지정된 유형의 모든 리소스에 적용할지 여부를 지정합니다.이 경우 해당 권한은 지정된 리소스 유형의 모든 인스턴스에 대해 평가됩니다.",
	"permissionResources": "이 권한을 특정 리소스 인스턴스에 적용해야 하도록 지정합니다.",
	"permissionScopes": "이 권한을 하나 이상의 범위에 적용해야 하도록 지정합니다.",
	"permissionPolicies": "이 정책 또는 권한으로 정의된 범위에 적용해야 하는 모든 정책을 지정합니다.",
	"permissionType": "이 권한을 지정된 유형의 모든 리소스 인스턴스에 적용하도록 지정합니다.",
	"permissionDecisionStrategy": "의사 결정 전략은 주어진 권한과 관련된 정책을 평가하는 방법과 최종 결정을 내리는 방법을 결정합니다.'긍정적'이란 최종 결정도 긍정적으로 나오려면 적어도 하나의 정책이 긍정적인 결정으로 평가되어야 함을 의미합니다.'만장일치'란 최종 결정도 긍정적으로 나오려면 모든 정책이 긍정적인 결정으로 평가되어야 함을 의미합니다.'합의'란 긍정적인 결정의 수가 부정적인 결정의 수보다 많아야 한다는 것을 의미합니다.양수와 음수의 수가 같으면 최종 결정은 음수입니다.",
	"permissionsEnabled": "이 역할을 관리하기 위해 세분화된 권한을 사용할 수 있는지 결정합니다.비활성화하면 현재 설정된 모든 권한이 삭제됩니다."
}